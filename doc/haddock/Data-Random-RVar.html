<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--Rendered using the Haskell Html Library v0.2-->
<HTML
><HEAD
><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8"
><TITLE
>Data.Random.RVar</TITLE
><LINK HREF="haddock.css" REL="stylesheet" TYPE="text/css"
><SCRIPT SRC="haddock-util.js" TYPE="text/javascript"
></SCRIPT
><SCRIPT TYPE="text/javascript"
>window.onload = function () {setSynopsis("mini_Data-Random-RVar.html")};</SCRIPT
></HEAD
><BODY
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="topbar"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD
><IMG SRC="haskell_icon.gif" WIDTH="16" HEIGHT="16" ALT=" "
></TD
><TD CLASS="title"
>random-fu-0.1.0.0: Random number generation</TD
><TD CLASS="topbut"
><A HREF="index.html"
>Contents</A
></TD
><TD CLASS="topbut"
><A HREF="doc-index.html"
>Index</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="modulebar"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD
><FONT SIZE="6"
>Data.Random.RVar</FONT
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section1"
>Description</TD
></TR
><TR
><TD CLASS="doc"
>Random variables.  An <TT
><A HREF="Data-Random-RVar.html#t%3ARVar"
>RVar</A
></TT
> is a sampleable random variable.  Because
 probability distributions form a monad, they are quite easy to work with
 in the standard Haskell monadic styles.  For examples, see the source for
 any of the Distribution instances - they all are defined in terms of
 <TT
><A HREF="Data-Random-RVar.html#t%3ARVar"
>RVar</A
></TT
>s.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section1"
>Synopsis</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="decl"
><SPAN CLASS="keyword"
>type</SPAN
> <A HREF="#t%3ARVar"
>RVar</A
> = <A HREF="Data-Random-RVar.html#t%3ARVarT"
>RVarT</A
> <A HREF="/usr/local/share/doc/mtl-1.1.0.2/html/Control-Monad-Identity.html#t%3AIdentity"
>Identity</A
></TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3ArunRVar"
>runRVar</A
> :: <A HREF="Data-Random-Source.html#t%3ARandomSource"
>RandomSource</A
> m s =&gt; <A HREF="Data-Random-RVar.html#t%3ARVar"
>RVar</A
> a -&gt; s -&gt; m a</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><SPAN CLASS="keyword"
>data</SPAN
>  <A HREF="#t%3ARVarT"
>RVarT</A
> m a</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3ArunRVarT"
>runRVarT</A
> :: (<A HREF="Data-Random-Lift.html#t%3ALift"
>Lift</A
> n m, <A HREF="Data-Random-Source.html#t%3ARandomSource"
>RandomSource</A
> m s) =&gt; <A HREF="Data-Random-RVar.html#t%3ARVarT"
>RVarT</A
> n a -&gt; s -&gt; m a</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3ArunRVarTWith"
>runRVarTWith</A
> :: <A HREF="Data-Random-Source.html#t%3ARandomSource"
>RandomSource</A
> m s =&gt; (<SPAN CLASS="keyword"
>forall</SPAN
> t.  n t -&gt; m t) -&gt; <A HREF="Data-Random-RVar.html#t%3ARVarT"
>RVarT</A
> n a -&gt; s -&gt; m a</TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section1"
>Documentation</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><SPAN CLASS="keyword"
>type</SPAN
> <A NAME="t:RVar"
><A NAME="t%3ARVar"
></A
></A
><B
>RVar</B
> = <A HREF="Data-Random-RVar.html#t%3ARVarT"
>RVarT</A
> <A HREF="/usr/local/share/doc/mtl-1.1.0.2/html/Control-Monad-Identity.html#t%3AIdentity"
>Identity</A
></TD
></TR
><TR
><TD CLASS="doc"
><P
>An opaque type modeling a &quot;random variable&quot; - a value 
 which depends on the outcome of some random event.  <TT
><A HREF="Data-Random-RVar.html#t%3ARVar"
>RVar</A
></TT
>s 
 can be conveniently defined by an imperative-looking style:
</P
><PRE
> normalPair =  do
     u &lt;- stdUniform
     t &lt;- stdUniform
     let r = sqrt (-2 * log u)
         theta = (2 * pi) * t
         
         x = r * cos theta
         y = r * sin theta
     return (x,y)
</PRE
><P
>OR by a more applicative style:
</P
><PRE
> logNormal = exp &lt;$&gt; stdNormal
</PRE
><P
>Once defined (in any style), there are a couple ways to sample <TT
><A HREF="Data-Random-RVar.html#t%3ARVar"
>RVar</A
></TT
>s:
</P
><UL
><LI
> In a monad, using a <TT
><A HREF="Data-Random-Source.html#t%3ARandomSource"
>RandomSource</A
></TT
>:
</LI
></UL
><PRE
> sampleFrom DevRandom (uniform 1 100) :: IO Int
</PRE
><UL
><LI
> As a pure function transforming a functional RNG:
</LI
></UL
><PRE
> sampleState (uniform 1 100) :: StdGen -&gt; (Int, StdGen)
</PRE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><A NAME="v:runRVar"
><A NAME="v%3ArunRVar"
></A
></A
><B
>runRVar</B
> :: <A HREF="Data-Random-Source.html#t%3ARandomSource"
>RandomSource</A
> m s =&gt; <A HREF="Data-Random-RVar.html#t%3ARVar"
>RVar</A
> a -&gt; s -&gt; m a</TD
></TR
><TR
><TD CLASS="doc"
>&quot;Run&quot; an <TT
><A HREF="Data-Random-RVar.html#t%3ARVar"
>RVar</A
></TT
> - samples the random variable from the provided
 source of entropy.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><SPAN CLASS="keyword"
>data</SPAN
>  <A NAME="t:RVarT"
><A NAME="t%3ARVarT"
></A
></A
><B
>RVarT</B
> m a </TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="ndoc"
><P
>A random variable with access to operations in an underlying monad.  Useful
 examples include any form of state for implementing random processes with hysteresis,
 or writer monads for implementing tracing of complicated algorithms.
</P
><P
>For example, a simple random walk can be implemented as an <TT
><A HREF="Data-Random-RVar.html#t%3ARVarT"
>RVarT</A
></TT
> <TT
><A HREF="/Library/Frameworks/GHC.framework/Versions/6.12.1/usr/share/doc/ghc/html/libraries/base-4.2.0.0/System-IO.html#t%3AIO"
>IO</A
></TT
> value:
</P
><PRE
> rwalkIO :: IO (RVarT IO Double)
 rwalkIO d = do
     lastVal &lt;- newIORef 0
     
     let x = do
             prev    &lt;- lift (readIORef lastVal)
             change  &lt;- rvarT StdNormal
             
             let new = prev + change
             lift (writeIORef lastVal new)
             return new
         
     return x
</PRE
><P
>To run the random walk, it must first be initialized, and then it can be sampled as usual:
</P
><PRE
> do
     rw &lt;- rwalkIO
     x &lt;- sampleFrom DevURandom rw
     y &lt;- sampleFrom DevURandom rw
     ...
</PRE
><P
>The same random-walk process as above can be implemented using MTL types
 as follows (using <TT
>import Control.Monad.Trans as MTL</TT
>):
</P
><PRE
> rwalkState :: RVarT (State Double) Double
 rwalkState = do
     prev &lt;- MTL.lift get
     change  &lt;- rvarT StdNormal
     
     let new = prev + change
     MTL.lift (put new)
     return new
</PRE
><P
>Invocation is straightforward (although a bit noisy) if you're used 
 to MTL, but there is a gotcha lurking here: <TT
>sample</TT
> and <TT
><A HREF="Data-Random-RVar.html#v%3ArunRVarT"
>runRVarT</A
></TT
> 
 inherit the extreme generality of <TT
><A HREF="Data-Random-Lift.html#v%3Alift"
>lift</A
></TT
>, so there will almost always
 need to be an explicit type signature lurking somewhere in any client 
 code making use of <TT
><A HREF="Data-Random-RVar.html#t%3ARVarT"
>RVarT</A
></TT
> with MTL types.  In this example, the 
 inferred type of <TT
>start</TT
> would be too general to be practical, so the
 signature for <TT
>rwalk</TT
>  explicitly fixes it to <TT
><A HREF="/Library/Frameworks/GHC.framework/Versions/6.12.1/usr/share/doc/ghc/html/libraries/base-4.2.0.0/Prelude.html#t%3ADouble"
>Double</A
></TT
>.  Alternatively, 
 in this case <TT
>sample</TT
> could be replaced with
 <TT
>\x -&gt; runRVarTWith MTL.lift x StdRandom</TT
>.
</P
><PRE
> rwalk :: Int -&gt; Double -&gt; StdGen -&gt; ([Double], StdGen)
 rwalk count start gen = evalState (runStateT (sample (replicateM count rwalkState)) gen) start
</PRE
></TD
></TR
><TR
><TD CLASS="section4"
><IMG SRC="minus.gif" CLASS="coll" ONCLICK="toggle(this,'i:RVarT')" ALT="show/hide"
> Instances</TD
></TR
><TR
><TD CLASS="body"
><DIV ID="i:RVarT" STYLE="display:block;"
><TABLE CLASS="vanilla" CELLSPACING="1" CELLPADDING="0"
><TR
><TD CLASS="decl"
><A HREF="/usr/local/share/doc/mtl-1.1.0.2/html/Control-Monad-Trans.html#t%3AMonadTrans"
>MonadTrans</A
> <A HREF="Data-Random-RVar.html#t%3ARVarT"
>RVarT</A
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="/Library/Frameworks/GHC.framework/Versions/6.12.1/usr/share/doc/ghc/html/libraries/base-4.2.0.0/Control-Monad.html#t%3AMonad"
>Monad</A
> (<A HREF="Data-Random-RVar.html#t%3ARVarT"
>RVarT</A
> n)</TD
></TR
><TR
><TD CLASS="decl"
><A HREF="/Library/Frameworks/GHC.framework/Versions/6.12.1/usr/share/doc/ghc/html/libraries/base-4.2.0.0/Control-Monad.html#t%3AFunctor"
>Functor</A
> (<A HREF="Data-Random-RVar.html#t%3ARVarT"
>RVarT</A
> n)</TD
></TR
><TR
><TD CLASS="decl"
><A HREF="/Library/Frameworks/GHC.framework/Versions/6.12.1/usr/share/doc/ghc/html/libraries/base-4.2.0.0/Control-Applicative.html#t%3AApplicative"
>Applicative</A
> (<A HREF="Data-Random-RVar.html#t%3ARVarT"
>RVarT</A
> n)</TD
></TR
><TR
><TD CLASS="decl"
><A HREF="/usr/local/share/doc/mtl-1.1.0.2/html/Control-Monad-Trans.html#t%3AMonadIO"
>MonadIO</A
> m =&gt; <A HREF="/usr/local/share/doc/mtl-1.1.0.2/html/Control-Monad-Trans.html#t%3AMonadIO"
>MonadIO</A
> (<A HREF="Data-Random-RVar.html#t%3ARVarT"
>RVarT</A
> m)</TD
></TR
><TR
><TD CLASS="decl"
><A HREF="Data-Random-Source.html#t%3AMonadRandom"
>MonadRandom</A
> (<A HREF="Data-Random-RVar.html#t%3ARVarT"
>RVarT</A
> n)</TD
></TR
><TR
><TD CLASS="decl"
><A HREF="Data-Random-Lift.html#t%3ALift"
>Lift</A
> m n =&gt; <A HREF="Data-Random-Sample.html#t%3ASampleable"
>Sampleable</A
> (<A HREF="Data-Random-RVar.html#t%3ARVarT"
>RVarT</A
> m) n t</TD
></TR
><TR
><TD CLASS="decl"
><A HREF="Data-Random-Lift.html#t%3ALift"
>Lift</A
> (<A HREF="Data-Random-RVar.html#t%3ARVarT"
>RVarT</A
> <A HREF="/usr/local/share/doc/mtl-1.1.0.2/html/Control-Monad-Identity.html#t%3AIdentity"
>Identity</A
>) (<A HREF="Data-Random-RVar.html#t%3ARVarT"
>RVarT</A
> m)</TD
></TR
></TABLE
></DIV
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><A NAME="v:runRVarT"
><A NAME="v%3ArunRVarT"
></A
></A
><B
>runRVarT</B
> :: (<A HREF="Data-Random-Lift.html#t%3ALift"
>Lift</A
> n m, <A HREF="Data-Random-Source.html#t%3ARandomSource"
>RandomSource</A
> m s) =&gt; <A HREF="Data-Random-RVar.html#t%3ARVarT"
>RVarT</A
> n a -&gt; s -&gt; m a</TD
></TR
><TR
><TD CLASS="doc"
><P
>&quot;Runs&quot; an <TT
><A HREF="Data-Random-RVar.html#t%3ARVarT"
>RVarT</A
></TT
>, sampling the random variable it defines.
</P
><P
>The <TT
><A HREF="Data-Random-Lift.html#t%3ALift"
>Lift</A
></TT
> context allows random variables to be defined using a minimal
 underlying functor (<TT
><A HREF="/usr/local/share/doc/mtl-1.1.0.2/html/Control-Monad-Identity.html#t%3AIdentity"
>Identity</A
></TT
> is sufficient for &quot;conventional&quot; random
 variables) and then sampled in any monad into which the underlying functor 
 can be embedded (which, for <TT
><A HREF="/usr/local/share/doc/mtl-1.1.0.2/html/Control-Monad-Identity.html#t%3AIdentity"
>Identity</A
></TT
>, is all monads).
</P
><P
>The lifting is very important - without it, every <TT
><A HREF="Data-Random-RVar.html#t%3ARVar"
>RVar</A
></TT
> would have
 to either be given access to the full capability of the monad in which it
 will eventually be sampled (which, incidentally, would also have to be 
 monomorphic so you couldn't sample one <TT
><A HREF="Data-Random-RVar.html#t%3ARVar"
>RVar</A
></TT
> in more than one monad)
 or functions manipulating <TT
><A HREF="Data-Random-RVar.html#t%3ARVar"
>RVar</A
></TT
>s would have to use higher-ranked 
 types to enforce the same kind of isolation and polymorphism.
</P
><P
>For non-standard liftings or those where you would rather not introduce a
 <TT
><A HREF="Data-Random-Lift.html#t%3ALift"
>Lift</A
></TT
> instance, see <TT
><A HREF="Data-Random-RVar.html#v%3ArunRVarTWith"
>runRVarTWith</A
></TT
>.
</P
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="decl"
><A NAME="v:runRVarTWith"
><A NAME="v%3ArunRVarTWith"
></A
></A
><B
>runRVarTWith</B
> :: <A HREF="Data-Random-Source.html#t%3ARandomSource"
>RandomSource</A
> m s =&gt; (<SPAN CLASS="keyword"
>forall</SPAN
> t.  n t -&gt; m t) -&gt; <A HREF="Data-Random-RVar.html#t%3ARVarT"
>RVarT</A
> n a -&gt; s -&gt; m a</TD
></TR
><TR
><TD CLASS="doc"
><P
>Like <TT
><A HREF="Data-Random-RVar.html#v%3ArunRVarT"
>runRVarT</A
></TT
> but allowing a user-specified lift operation.  This 
 operation must obey the &quot;monad transformer&quot; laws:
</P
><PRE
> lift . return = return
 lift (x &gt;&gt;= f) = (lift x) &gt;&gt;= (lift . f)
</PRE
><P
>One example of a useful non-standard lifting would be one that takes <TT
>State s</TT
> to
 another monad with a different state representation (such as <TT
>IO</TT
> with the
 state mapped to an <TT
>IORef</TT
>):
</P
><PRE
> embedState :: (Monad m) =&gt; m s -&gt; (s -&gt; m ()) -&gt; State s a -&gt; m a
 embedState get put = \m -&gt; do
     s &lt;- get
     (res,s) &lt;- return (runState m s)
     put s
     return res
</PRE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="botbar"
>Produced by <A HREF="http://www.haskell.org/haddock/"
>Haddock</A
> version 2.6.0</TD
></TR
></TABLE
></BODY
></HTML
>
