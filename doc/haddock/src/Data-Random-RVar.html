<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://www.cs.york.ac.uk/fp/darcs/hscolour/ -->
<title>src/Data/Random/RVar.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-
<a name="line-2"></a> -      ``Data/Random/RVar''
<a name="line-3"></a> -}</span>
<a name="line-4"></a><span class='hs-comment'>{-# LANGUAGE
<a name="line-5"></a>    RankNTypes,
<a name="line-6"></a>    MultiParamTypeClasses,
<a name="line-7"></a>    FlexibleInstances, 
<a name="line-8"></a>    GADTs
<a name="line-9"></a>  #-}</span>
<a name="line-10"></a>
<a name="line-11"></a><span class='hs-comment'>-- |Random variables.  An 'RVar' is a sampleable random variable.  Because</span>
<a name="line-12"></a><span class='hs-comment'>-- probability distributions form a monad, they are quite easy to work with</span>
<a name="line-13"></a><span class='hs-comment'>-- in the standard Haskell monadic styles.  For examples, see the source for</span>
<a name="line-14"></a><span class='hs-comment'>-- any of the 'Distribution' instances - they all are defined in terms of</span>
<a name="line-15"></a><span class='hs-comment'>-- 'RVar's.</span>
<a name="line-16"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Random</span><span class='hs-varop'>.</span><span class='hs-conid'>RVar</span>
<a name="line-17"></a>    <span class='hs-layout'>(</span> <span class='hs-conid'>RVar</span>
<a name="line-18"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>runRVar</span>
<a name="line-19"></a>    <span class='hs-layout'>,</span> <span class='hs-conid'>RVarT</span>
<a name="line-20"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>runRVarT</span>
<a name="line-21"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>runRVarTWith</span>
<a name="line-22"></a>    <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-23"></a>
<a name="line-24"></a>
<a name="line-25"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Random</span><span class='hs-varop'>.</span><span class='hs-conid'>Internal</span><span class='hs-varop'>.</span><span class='hs-conid'>Primitives</span>
<a name="line-26"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Random</span><span class='hs-varop'>.</span><span class='hs-conid'>Source</span>
<a name="line-27"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Random</span><span class='hs-varop'>.</span><span class='hs-conid'>Lift</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>L</span>
<a name="line-28"></a>
<a name="line-29"></a><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Monad</span><span class='hs-varop'>.</span><span class='hs-conid'>Trans</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>T</span>
<a name="line-30"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Applicative</span>
<a name="line-31"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Monad</span><span class='hs-varop'>.</span><span class='hs-conid'>Identity</span>
<a name="line-32"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Monad</span><span class='hs-varop'>.</span><span class='hs-conid'>Prompt</span> <span class='hs-layout'>(</span><span class='hs-conid'>PromptT</span><span class='hs-layout'>,</span> <span class='hs-varid'>runPromptT</span><span class='hs-layout'>,</span> <span class='hs-varid'>prompt</span><span class='hs-layout'>)</span>
<a name="line-33"></a>
<a name="line-34"></a><a name="RVar"></a><span class='hs-comment'>-- |An opaque type modeling a \"random variable\" - a value </span>
<a name="line-35"></a><a name="RVar"></a><span class='hs-comment'>-- which depends on the outcome of some random event.  'RVar's </span>
<a name="line-36"></a><a name="RVar"></a><span class='hs-comment'>-- can be conveniently defined by an imperative-looking style:</span>
<a name="line-37"></a><a name="RVar"></a><span class='hs-comment'>-- </span>
<a name="line-38"></a><a name="RVar"></a><span class='hs-comment'>-- &gt; normalPair =  do</span>
<a name="line-39"></a><a name="RVar"></a><span class='hs-comment'>-- &gt;     u &lt;- stdUniform</span>
<a name="line-40"></a><a name="RVar"></a><span class='hs-comment'>-- &gt;     t &lt;- stdUniform</span>
<a name="line-41"></a><a name="RVar"></a><span class='hs-comment'>-- &gt;     let r = sqrt (-2 * log u)</span>
<a name="line-42"></a><a name="RVar"></a><span class='hs-comment'>-- &gt;         theta = (2 * pi) * t</span>
<a name="line-43"></a><a name="RVar"></a><span class='hs-comment'>-- &gt;         </span>
<a name="line-44"></a><a name="RVar"></a><span class='hs-comment'>-- &gt;         x = r * cos theta</span>
<a name="line-45"></a><a name="RVar"></a><span class='hs-comment'>-- &gt;         y = r * sin theta</span>
<a name="line-46"></a><a name="RVar"></a><span class='hs-comment'>-- &gt;     return (x,y)</span>
<a name="line-47"></a><a name="RVar"></a><span class='hs-comment'>-- </span>
<a name="line-48"></a><a name="RVar"></a><span class='hs-comment'>-- OR by a more applicative style:</span>
<a name="line-49"></a><a name="RVar"></a><span class='hs-comment'>-- </span>
<a name="line-50"></a><a name="RVar"></a><span class='hs-comment'>-- &gt; logNormal = exp &lt;$&gt; stdNormal</span>
<a name="line-51"></a><a name="RVar"></a><span class='hs-comment'>--</span>
<a name="line-52"></a><a name="RVar"></a><span class='hs-comment'>-- Once defined (in any style), there are a couple ways to sample 'RVar's:</span>
<a name="line-53"></a><a name="RVar"></a><span class='hs-comment'>-- </span>
<a name="line-54"></a><a name="RVar"></a><span class='hs-comment'>-- * In a monad, using a 'RandomSource':</span>
<a name="line-55"></a><a name="RVar"></a><span class='hs-comment'>-- </span>
<a name="line-56"></a><a name="RVar"></a><span class='hs-comment'>-- &gt; sampleFrom DevRandom (uniform 1 100) :: IO Int</span>
<a name="line-57"></a><a name="RVar"></a><span class='hs-comment'>-- </span>
<a name="line-58"></a><a name="RVar"></a><span class='hs-comment'>-- * As a pure function transforming a functional RNG:</span>
<a name="line-59"></a><a name="RVar"></a><span class='hs-comment'>-- </span>
<a name="line-60"></a><a name="RVar"></a><span class='hs-comment'>-- &gt; sampleState (uniform 1 100) :: StdGen -&gt; (Int, StdGen)</span>
<a name="line-61"></a><a name="RVar"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>RVar</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RVarT</span> <span class='hs-conid'>Identity</span>
<a name="line-62"></a>
<a name="line-63"></a><a name="runRVar"></a><span class='hs-comment'>-- |\"Run\" an 'RVar' - samples the random variable from the provided</span>
<a name="line-64"></a><span class='hs-comment'>-- source of entropy.</span>
<a name="line-65"></a><span class='hs-definition'>runRVar</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>RandomSource</span> <span class='hs-varid'>m</span> <span class='hs-varid'>s</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>RVar</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>s</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a</span>
<a name="line-66"></a><span class='hs-definition'>runRVar</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>runRVarT</span>
<a name="line-67"></a>
<a name="line-68"></a><a name="RVarT"></a><span class='hs-comment'>-- |A random variable with access to operations in an underlying monad.  Useful</span>
<a name="line-69"></a><a name="RVarT"></a><span class='hs-comment'>-- examples include any form of state for implementing random processes with hysteresis,</span>
<a name="line-70"></a><a name="RVarT"></a><span class='hs-comment'>-- or writer monads for implementing tracing of complicated algorithms.</span>
<a name="line-71"></a><a name="RVarT"></a><span class='hs-comment'>-- </span>
<a name="line-72"></a><a name="RVarT"></a><span class='hs-comment'>-- For example, a simple random walk can be implemented as an 'RVarT' 'IO' value:</span>
<a name="line-73"></a><a name="RVarT"></a><span class='hs-comment'>--</span>
<a name="line-74"></a><a name="RVarT"></a><span class='hs-comment'>-- &gt; rwalkIO :: IO (RVarT IO Double)</span>
<a name="line-75"></a><a name="RVarT"></a><span class='hs-comment'>-- &gt; rwalkIO d = do</span>
<a name="line-76"></a><a name="RVarT"></a><span class='hs-comment'>-- &gt;     lastVal &lt;- newIORef 0</span>
<a name="line-77"></a><a name="RVarT"></a><span class='hs-comment'>-- &gt;     </span>
<a name="line-78"></a><a name="RVarT"></a><span class='hs-comment'>-- &gt;     let x = do</span>
<a name="line-79"></a><a name="RVarT"></a><span class='hs-comment'>-- &gt;             prev    &lt;- lift (readIORef lastVal)</span>
<a name="line-80"></a><a name="RVarT"></a><span class='hs-comment'>-- &gt;             change  &lt;- rvarT StdNormal</span>
<a name="line-81"></a><a name="RVarT"></a><span class='hs-comment'>-- &gt;             </span>
<a name="line-82"></a><a name="RVarT"></a><span class='hs-comment'>-- &gt;             let new = prev + change</span>
<a name="line-83"></a><a name="RVarT"></a><span class='hs-comment'>-- &gt;             lift (writeIORef lastVal new)</span>
<a name="line-84"></a><a name="RVarT"></a><span class='hs-comment'>-- &gt;             return new</span>
<a name="line-85"></a><a name="RVarT"></a><span class='hs-comment'>-- &gt;         </span>
<a name="line-86"></a><a name="RVarT"></a><span class='hs-comment'>-- &gt;     return x</span>
<a name="line-87"></a><a name="RVarT"></a><span class='hs-comment'>--</span>
<a name="line-88"></a><a name="RVarT"></a><span class='hs-comment'>-- To run the random walk, it must first be initialized, and then it can be sampled as usual:</span>
<a name="line-89"></a><a name="RVarT"></a><span class='hs-comment'>--</span>
<a name="line-90"></a><a name="RVarT"></a><span class='hs-comment'>-- &gt; do</span>
<a name="line-91"></a><a name="RVarT"></a><span class='hs-comment'>-- &gt;     rw &lt;- rwalkIO</span>
<a name="line-92"></a><a name="RVarT"></a><span class='hs-comment'>-- &gt;     x &lt;- sampleFrom DevURandom rw</span>
<a name="line-93"></a><a name="RVarT"></a><span class='hs-comment'>-- &gt;     y &lt;- sampleFrom DevURandom rw</span>
<a name="line-94"></a><a name="RVarT"></a><span class='hs-comment'>-- &gt;     ...</span>
<a name="line-95"></a><a name="RVarT"></a><span class='hs-comment'>--</span>
<a name="line-96"></a><a name="RVarT"></a><span class='hs-comment'>-- The same random-walk process as above can be implemented using MTL types</span>
<a name="line-97"></a><a name="RVarT"></a><span class='hs-comment'>-- as follows (using @import Control.Monad.Trans as MTL@):</span>
<a name="line-98"></a><a name="RVarT"></a><span class='hs-comment'>-- </span>
<a name="line-99"></a><a name="RVarT"></a><span class='hs-comment'>-- &gt; rwalkState :: RVarT (State Double) Double</span>
<a name="line-100"></a><a name="RVarT"></a><span class='hs-comment'>-- &gt; rwalkState = do</span>
<a name="line-101"></a><a name="RVarT"></a><span class='hs-comment'>-- &gt;     prev &lt;- MTL.lift get</span>
<a name="line-102"></a><a name="RVarT"></a><span class='hs-comment'>-- &gt;     change  &lt;- rvarT StdNormal</span>
<a name="line-103"></a><a name="RVarT"></a><span class='hs-comment'>-- &gt;     </span>
<a name="line-104"></a><a name="RVarT"></a><span class='hs-comment'>-- &gt;     let new = prev + change</span>
<a name="line-105"></a><a name="RVarT"></a><span class='hs-comment'>-- &gt;     MTL.lift (put new)</span>
<a name="line-106"></a><a name="RVarT"></a><span class='hs-comment'>-- &gt;     return new</span>
<a name="line-107"></a><a name="RVarT"></a><span class='hs-comment'>-- </span>
<a name="line-108"></a><a name="RVarT"></a><span class='hs-comment'>-- Invocation is straightforward (although a bit noisy) if you're used </span>
<a name="line-109"></a><a name="RVarT"></a><span class='hs-comment'>-- to MTL, but there is a gotcha lurking here: @sample@ and 'runRVarT' </span>
<a name="line-110"></a><a name="RVarT"></a><span class='hs-comment'>-- inherit the extreme generality of 'lift', so there will almost always</span>
<a name="line-111"></a><a name="RVarT"></a><span class='hs-comment'>-- need to be an explicit type signature lurking somewhere in any client </span>
<a name="line-112"></a><a name="RVarT"></a><span class='hs-comment'>-- code making use of 'RVarT' with MTL types.  In this example, the </span>
<a name="line-113"></a><a name="RVarT"></a><span class='hs-comment'>-- inferred type of @start@ would be too general to be practical, so the</span>
<a name="line-114"></a><a name="RVarT"></a><span class='hs-comment'>-- signature for @rwalk@  explicitly fixes it to 'Double'.  Alternatively, </span>
<a name="line-115"></a><a name="RVarT"></a><span class='hs-comment'>-- in this case @sample@ could be replaced with</span>
<a name="line-116"></a><a name="RVarT"></a><span class='hs-comment'>-- @\\x -&gt; runRVarTWith MTL.lift x StdRandom@.</span>
<a name="line-117"></a><a name="RVarT"></a><span class='hs-comment'>-- </span>
<a name="line-118"></a><a name="RVarT"></a><span class='hs-comment'>-- &gt; rwalk :: Int -&gt; Double -&gt; StdGen -&gt; ([Double], StdGen)</span>
<a name="line-119"></a><a name="RVarT"></a><span class='hs-comment'>-- &gt; rwalk count start gen = evalState (runStateT (sample (replicateM count rwalkState)) gen) start</span>
<a name="line-120"></a><a name="RVarT"></a><span class='hs-keyword'>newtype</span> <span class='hs-conid'>RVarT</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RVarT</span> <span class='hs-layout'>{</span> <span class='hs-varid'>unRVarT</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>PromptT</span> <span class='hs-conid'>Prim</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a</span> <span class='hs-layout'>}</span>
<a name="line-121"></a>
<a name="line-122"></a><a name="runRVarT"></a><span class='hs-comment'>-- | \"Runs\" an 'RVarT', sampling the random variable it defines.</span>
<a name="line-123"></a><span class='hs-comment'>-- </span>
<a name="line-124"></a><span class='hs-comment'>-- The 'Lift' context allows random variables to be defined using a minimal</span>
<a name="line-125"></a><span class='hs-comment'>-- underlying functor ('Identity' is sufficient for \"conventional\" random</span>
<a name="line-126"></a><span class='hs-comment'>-- variables) and then sampled in any monad into which the underlying functor </span>
<a name="line-127"></a><span class='hs-comment'>-- can be embedded (which, for 'Identity', is all monads).</span>
<a name="line-128"></a><span class='hs-comment'>-- </span>
<a name="line-129"></a><span class='hs-comment'>-- The lifting is very important - without it, every 'RVar' would have</span>
<a name="line-130"></a><span class='hs-comment'>-- to either be given access to the full capability of the monad in which it</span>
<a name="line-131"></a><span class='hs-comment'>-- will eventually be sampled (which, incidentally, would also have to be </span>
<a name="line-132"></a><span class='hs-comment'>-- monomorphic so you couldn't sample one 'RVar' in more than one monad)</span>
<a name="line-133"></a><span class='hs-comment'>-- or functions manipulating 'RVar's would have to use higher-ranked </span>
<a name="line-134"></a><span class='hs-comment'>-- types to enforce the same kind of isolation and polymorphism.</span>
<a name="line-135"></a><span class='hs-comment'>-- </span>
<a name="line-136"></a><span class='hs-comment'>-- For non-standard liftings or those where you would rather not introduce a</span>
<a name="line-137"></a><span class='hs-comment'>-- 'Lift' instance, see 'runRVarTWith'.</span>
<a name="line-138"></a><span class='hs-comment'>{-# INLINE runRVarT #-}</span>
<a name="line-139"></a><span class='hs-definition'>runRVarT</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lift</span> <span class='hs-varid'>n</span> <span class='hs-varid'>m</span><span class='hs-layout'>,</span> <span class='hs-conid'>RandomSource</span> <span class='hs-varid'>m</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>RVarT</span> <span class='hs-varid'>n</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>s</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a</span>
<a name="line-140"></a><span class='hs-definition'>runRVarT</span> <span class='hs-layout'>(</span><span class='hs-conid'>RVarT</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-varid'>src</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>runPromptT</span> <span class='hs-varid'>return</span> <span class='hs-varid'>bindP</span> <span class='hs-varid'>bindN</span> <span class='hs-varid'>m</span>
<a name="line-141"></a>    <span class='hs-keyword'>where</span>
<a name="line-142"></a>        <span class='hs-varid'>bindP</span> <span class='hs-varid'>prim</span> <span class='hs-varid'>cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getRandomPrimFrom</span> <span class='hs-varid'>src</span> <span class='hs-varid'>prim</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>cont</span>
<a name="line-143"></a>        <span class='hs-varid'>bindN</span> <span class='hs-varid'>nExp</span> <span class='hs-varid'>cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lift</span> <span class='hs-varid'>nExp</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>cont</span>
<a name="line-144"></a>
<a name="line-145"></a><a name="runRVarTWith"></a><span class='hs-comment'>-- |Like 'runRVarT' but allowing a user-specified lift operation.  This </span>
<a name="line-146"></a><span class='hs-comment'>-- operation must obey the \"monad transformer\" laws:</span>
<a name="line-147"></a><span class='hs-comment'>--</span>
<a name="line-148"></a><span class='hs-comment'>-- &gt; lift . return = return</span>
<a name="line-149"></a><span class='hs-comment'>-- &gt; lift (x &gt;&gt;= f) = (lift x) &gt;&gt;= (lift . f)</span>
<a name="line-150"></a><span class='hs-comment'>--</span>
<a name="line-151"></a><span class='hs-comment'>-- One example of a useful non-standard lifting would be one that takes @State s@ to</span>
<a name="line-152"></a><span class='hs-comment'>-- another monad with a different state representation (such as @IO@ with the</span>
<a name="line-153"></a><span class='hs-comment'>-- state mapped to an @IORef@):</span>
<a name="line-154"></a><span class='hs-comment'>--</span>
<a name="line-155"></a><span class='hs-comment'>-- &gt; embedState :: (Monad m) =&gt; m s -&gt; (s -&gt; m ()) -&gt; State s a -&gt; m a</span>
<a name="line-156"></a><span class='hs-comment'>-- &gt; embedState get put = \m -&gt; do</span>
<a name="line-157"></a><span class='hs-comment'>-- &gt;     s &lt;- get</span>
<a name="line-158"></a><span class='hs-comment'>-- &gt;     (res,s) &lt;- return (runState m s)</span>
<a name="line-159"></a><span class='hs-comment'>-- &gt;     put s</span>
<a name="line-160"></a><span class='hs-comment'>-- &gt;     return res</span>
<a name="line-161"></a><span class='hs-comment'>{-# INLINE runRVarTWith #-}</span>
<a name="line-162"></a><span class='hs-definition'>runRVarTWith</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>RandomSource</span> <span class='hs-varid'>m</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyword'>forall</span> <span class='hs-varid'>t</span><span class='hs-varop'>.</span> <span class='hs-varid'>n</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>RVarT</span> <span class='hs-varid'>n</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>s</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span> <span class='hs-varid'>a</span>
<a name="line-163"></a><span class='hs-definition'>runRVarTWith</span> <span class='hs-varid'>liftN</span> <span class='hs-layout'>(</span><span class='hs-conid'>RVarT</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-varid'>src</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>runPromptT</span> <span class='hs-varid'>return</span> <span class='hs-varid'>bindP</span> <span class='hs-varid'>bindN</span> <span class='hs-varid'>m</span>
<a name="line-164"></a>    <span class='hs-keyword'>where</span>
<a name="line-165"></a>        <span class='hs-varid'>bindP</span> <span class='hs-varid'>prim</span> <span class='hs-varid'>cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getRandomPrimFrom</span> <span class='hs-varid'>src</span> <span class='hs-varid'>prim</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>cont</span>
<a name="line-166"></a>        <span class='hs-varid'>bindN</span> <span class='hs-varid'>nExp</span> <span class='hs-varid'>cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>liftN</span> <span class='hs-varid'>nExp</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>cont</span>
<a name="line-167"></a>
<a name="line-168"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Functor</span> <span class='hs-layout'>(</span><span class='hs-conid'>RVarT</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-169"></a>    <span class='hs-varid'>fmap</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>liftM</span>
<a name="line-170"></a>
<a name="line-171"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Monad</span> <span class='hs-layout'>(</span><span class='hs-conid'>RVarT</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-172"></a>    <span class='hs-varid'>return</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RVarT</span> <span class='hs-layout'>(</span><span class='hs-varid'>return</span> <span class='hs-varop'>$!</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-173"></a>    <span class='hs-varid'>fail</span> <span class='hs-varid'>s</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RVarT</span> <span class='hs-layout'>(</span><span class='hs-varid'>fail</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span>
<a name="line-174"></a>    <span class='hs-layout'>(</span><span class='hs-conid'>RVarT</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>k</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RVarT</span> <span class='hs-layout'>(</span><span class='hs-varid'>m</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>x</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>x</span> <span class='hs-varop'>`seq`</span> <span class='hs-varid'>unRVarT</span> <span class='hs-layout'>(</span><span class='hs-varid'>k</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-175"></a>
<a name="line-176"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Applicative</span> <span class='hs-layout'>(</span><span class='hs-conid'>RVarT</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-177"></a>    <span class='hs-varid'>pure</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span>
<a name="line-178"></a>    <span class='hs-layout'>(</span><span class='hs-varop'>&lt;*&gt;</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ap</span>
<a name="line-179"></a>
<a name="line-180"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>T</span><span class='hs-varop'>.</span><span class='hs-conid'>MonadTrans</span> <span class='hs-conid'>RVarT</span> <span class='hs-keyword'>where</span>
<a name="line-181"></a>    <span class='hs-varid'>lift</span> <span class='hs-varid'>m</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RVarT</span> <span class='hs-layout'>(</span><span class='hs-conid'>T</span><span class='hs-varop'>.</span><span class='hs-varid'>lift</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span>
<a name="line-182"></a>
<a name="line-183"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Lift</span> <span class='hs-layout'>(</span><span class='hs-conid'>RVarT</span> <span class='hs-conid'>Identity</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>RVarT</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-184"></a>    <span class='hs-varid'>lift</span> <span class='hs-layout'>(</span><span class='hs-conid'>RVarT</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RVarT</span> <span class='hs-layout'>(</span><span class='hs-varid'>runPromptT</span> <span class='hs-varid'>return</span> <span class='hs-varid'>bindP</span> <span class='hs-varid'>bindN</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span>
<a name="line-185"></a>        <span class='hs-keyword'>where</span>
<a name="line-186"></a>            <span class='hs-varid'>bindP</span> <span class='hs-varid'>prim</span>  <span class='hs-varid'>cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>prompt</span> <span class='hs-varid'>prim</span> <span class='hs-varop'>&gt;&gt;=</span> <span class='hs-varid'>cont</span>
<a name="line-187"></a>            <span class='hs-varid'>bindN</span> <span class='hs-varid'>idExp</span> <span class='hs-varid'>cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cont</span> <span class='hs-layout'>(</span><span class='hs-varid'>runIdentity</span> <span class='hs-varid'>idExp</span><span class='hs-layout'>)</span>
<a name="line-188"></a>
<a name="line-189"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>T</span><span class='hs-varop'>.</span><span class='hs-conid'>MonadIO</span> <span class='hs-varid'>m</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>T</span><span class='hs-varop'>.</span><span class='hs-conid'>MonadIO</span> <span class='hs-layout'>(</span><span class='hs-conid'>RVarT</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-190"></a>    <span class='hs-varid'>liftIO</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>T</span><span class='hs-varop'>.</span><span class='hs-varid'>lift</span> <span class='hs-varop'>.</span> <span class='hs-conid'>T</span><span class='hs-varop'>.</span><span class='hs-varid'>liftIO</span>
<a name="line-191"></a>
<a name="line-192"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>MonadRandom</span> <span class='hs-layout'>(</span><span class='hs-conid'>RVarT</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-193"></a>    <span class='hs-varid'>supportedPrims</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-194"></a>    <span class='hs-comment'>{-# INLINE getSupportedRandomPrim #-}</span>
<a name="line-195"></a>    <span class='hs-varid'>getSupportedRandomPrim</span> <span class='hs-varid'>p</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RVarT</span> <span class='hs-layout'>(</span><span class='hs-varid'>prompt</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-196"></a>    <span class='hs-comment'>{-# INLINE getRandomPrim #-}</span>
<a name="line-197"></a>    <span class='hs-varid'>getRandomPrim</span> <span class='hs-varid'>p</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RVarT</span> <span class='hs-layout'>(</span><span class='hs-varid'>prompt</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-198"></a>
<a name="line-199"></a><span class='hs-comment'>-- I would really like to be able to do this, but I can't because of the</span>
<a name="line-200"></a><span class='hs-comment'>-- blasted Eq and Show in Num's class context...</span>
<a name="line-201"></a><span class='hs-comment'>-- instance (Applicative m, Num a) =&gt; Num (RVarT m a) where</span>
<a name="line-202"></a><span class='hs-comment'>--     (+) = liftA2 (+)</span>
<a name="line-203"></a><span class='hs-comment'>--     (-) = liftA2 (-)</span>
<a name="line-204"></a><span class='hs-comment'>--     (*) = liftA2 (*)</span>
<a name="line-205"></a><span class='hs-comment'>--     negate = liftA negate</span>
<a name="line-206"></a><span class='hs-comment'>--     signum = liftA signum</span>
<a name="line-207"></a><span class='hs-comment'>--     abs = liftA abs</span>
<a name="line-208"></a><span class='hs-comment'>--     fromInteger = pure . fromInteger</span>
</pre></body>
</html>
