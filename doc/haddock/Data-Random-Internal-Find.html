<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--Rendered using the Haskell Html Library v0.2-->
<HTML
><HEAD
><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8"
><TITLE
>Data.Random.Internal.Find</TITLE
><LINK HREF="haddock.css" REL="stylesheet" TYPE="text/css"
><SCRIPT SRC="haddock-util.js" TYPE="text/javascript"
></SCRIPT
><SCRIPT TYPE="text/javascript"
>window.onload = function () {setSynopsis("mini_Data-Random-Internal-Find.html")};</SCRIPT
></HEAD
><BODY
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="topbar"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD
><IMG SRC="haskell_icon.gif" WIDTH="16" HEIGHT="16" ALT=" "
></TD
><TD CLASS="title"
>random-fu-0.1.0.0: Random number generation</TD
><TD CLASS="topbut"
><A HREF="src/Data-Random-Internal-Find.html"
>Source code</A
></TD
><TD CLASS="topbut"
><A HREF="index.html"
>Contents</A
></TD
><TD CLASS="topbut"
><A HREF="doc-index.html"
>Index</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="modulebar"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD
><FONT SIZE="6"
>Data.Random.Internal.Find</FONT
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section1"
>Synopsis</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="body"
><TABLE CLASS="vanilla" CELLSPACING="0" CELLPADDING="0"
><TR
><TD CLASS="decl"
><A HREF="#v%3AfindMax"
>findMax</A
> :: (<A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t%3AFractional"
>Fractional</A
> a, <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Ord.html#t%3AOrd"
>Ord</A
> a) =&gt; (a -&gt; <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Bool.html#t%3ABool"
>Bool</A
>) -&gt; a</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AfindMin"
>findMin</A
> :: (<A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t%3AFractional"
>Fractional</A
> a, <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Ord.html#t%3AOrd"
>Ord</A
> a) =&gt; (a -&gt; <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Bool.html#t%3ABool"
>Bool</A
>) -&gt; a</TD
></TR
><TR
><TD CLASS="s8"
></TD
></TR
><TR
><TD CLASS="decl"
><A HREF="#v%3AfindMinFrom"
>findMinFrom</A
> :: (<A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t%3AFractional"
>Fractional</A
> a, <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Ord.html#t%3AOrd"
>Ord</A
> a) =&gt; a -&gt; a -&gt; (a -&gt; <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Bool.html#t%3ABool"
>Bool</A
>) -&gt; a</TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="section1"
>Documentation</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:findMax"
><A NAME="v%3AfindMax"
></A
></A
><B
>findMax</B
> :: (<A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t%3AFractional"
>Fractional</A
> a, <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Ord.html#t%3AOrd"
>Ord</A
> a) =&gt; (a -&gt; <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Bool.html#t%3ABool"
>Bool</A
>) -&gt; a</TD
><TD CLASS="declbut"
><A HREF="src/Data-Random-Internal-Find.html#findMax"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:findMin"
><A NAME="v%3AfindMin"
></A
></A
><B
>findMin</B
> :: (<A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t%3AFractional"
>Fractional</A
> a, <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Ord.html#t%3AOrd"
>Ord</A
> a) =&gt; (a -&gt; <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Bool.html#t%3ABool"
>Bool</A
>) -&gt; a</TD
><TD CLASS="declbut"
><A HREF="src/Data-Random-Internal-Find.html#findMin"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Given an upward-closed predicate on an ordered Fractional type,
 find the smallest value satisfying the predicate.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="topdecl"
><TABLE CLASS="declbar"
><TR
><TD CLASS="declname"
><A NAME="v:findMinFrom"
><A NAME="v%3AfindMinFrom"
></A
></A
><B
>findMinFrom</B
> :: (<A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t%3AFractional"
>Fractional</A
> a, <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Ord.html#t%3AOrd"
>Ord</A
> a) =&gt; a -&gt; a -&gt; (a -&gt; <A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Bool.html#t%3ABool"
>Bool</A
>) -&gt; a</TD
><TD CLASS="declbut"
><A HREF="src/Data-Random-Internal-Find.html#findMinFrom"
>Source</A
></TD
></TR
></TABLE
></TD
></TR
><TR
><TD CLASS="doc"
>Given an upward-closed predicate on an ordered Fractional type,
 find the smallest value satisfying the predicate.  Starts at the
 specified point with the specified stepsize, performs an exponential
 search out from there until it finds an interval bracketing the
 change-point of the predicate, and then performs a bisection search
 to isolate the change point.  Note that infinitely-divisible domains 
 such as <TT
><A HREF="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t%3ARational"
>Rational</A
></TT
> cannot be searched by this function because it does
 not terminate until it reaches a point where further subdivision of the
 interval has no effect.
</TD
></TR
><TR
><TD CLASS="s15"
></TD
></TR
><TR
><TD CLASS="botbar"
>Produced by <A HREF="http://www.haskell.org/haddock/"
>Haddock</A
> version 2.6.0</TD
></TR
></TABLE
></BODY
></HTML
>
